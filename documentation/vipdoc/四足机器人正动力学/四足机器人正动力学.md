# 四足机器人正动力学

## 正动力学示例

正动力学是机器人算法中相对难以理解的部分。考虑问题$1$：

![](图片\公式\照片\质量受力模型.png)

一个质量为$m$的质点，受到作用力为$F$的作用力时，其加速度为$a = \frac{F}{m}$。这是一个最简单的质点受力模型。如果质点当前具有速度$v$，其他条件不变的情况下，加速度计算保持不变，则下一个计算周期时，可以认为速度更新为$v' = v + a \cdot \Delta t$。

再考虑问题$2$：

![](图片\公式\照片\单杆受力模型.png)

如果对杆质心而言，质量和惯量已知，则此时的$v' = v + a \cdot \Delta t$，$\omega ' = \omega + \frac{\frac{1}{2}L \times F}{I} \cdot \Delta t$

## 正动力学目标

通过上述两个简单的例子，说明正动力学所需要解决的问题：

输入：

1. 构件所有的物理参数，包括质量、惯性矩阵、集合参数、关节类型等；
2. 构件所有的运动状态，包括位置、姿态、速度、角速度等；
3. 构件所受的作用力，包括外力、关节力矩等；

输出：

1. 构件的加速度，包括质心加速度、关节角加速度；
2. 构件的操作空间惯性矩阵；

## 铰接模型的作用力方程
首先需要介绍铰链的力和加速度的关系式：
$$
f = I^A a + P^A \label{铰链的力和加速度的关系式}
$$
$\ref{铰链的力和加速度的关系式}$式表明的是，当一个作用力作用在任何物体上时，这个作用力使物体具备加速度的同时，在约束的自由度上则产生了相应的静力。

比如：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\公式\照片\约束单杆受力模型.png)

作用力$F$在铰链处的投影中的力矩，让构件产生了角加速度，对应到$\ref{铰链的力和加速度的关系式}$式的等号右侧第一项。$F$为对铰链（无论铰链是否运动）的静力作用对应到$\ref{铰链的力和加速度的关系式}$式的等号右侧第二项。

## 铰接体正动力学推导

问题3：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\公式\照片\二连杆受力模型.png)

图中的最后一个构件可以看成一个固定体。后续的部分将会采用是$6D~space$进行描述。详细参考《Rigid Body Dynamics Algorithms》。假设所有的变量都公共坐标系下表达。

**关节力矩推导**

假设关节$1$上的作用力为$f_1$，关节$2$上的为$f_2$，则对构件$1$而言，实际受到的外力为：
$$
f_1' = f_1 - f_2
$$
构件$2$的加速度是构件$2$的加速度，再叠加关节加速度和构件$2$的科氏加速度$C$：
$$
a_2 = a_1 + S^T_2 \ddot q_2
$$
科氏加速度计算参考《Rigid Body Dynamics Algorithms》中逆动力学。

关节上的力矩满足：
$$
S^T_2 f_2 = \tau_2 \\
$$
从而：
$$
\begin{array}{rl}
\tau_2 &= S^T_2 f_2 \\
&= S^T (I^A_2 a_2 + p^A) \\
&= S^T (I^A_2 (a_1 + C + S_2 \ddot q_2) + p^A) \\
\end{array}
$$
**关节角加速度推导**

该式利用了$\ref{铰链的力和加速度的关系式}$式的结论。

从而关节加速度为：
$$
\ddot q_2 = (S_2 I^A_2 S_2^T)^{-1}(\tau_2 - S^T_2(I^A_2 (a_1 + C)+ p^A_2))
$$
**子构件对父构件的影响**

对$1$构件而言：
$$
\begin{array}{rl}
f_1 &= f_1' + f_2 \\
&= I_1^A a_1 + p_1^A + I_2^A a_2 + p_2^A \\
&= I_1^A a_1 + p_1^A + I_2^A (a_1 + C + S_2 \ddot q_2) + p_2^A \\
&= I_1^A a_1 + p_1^A + I_2^A (a_1 + C + S_2 (S_2 I^A_2 S_2^T)^{-1}(\tau_2 - S^T_2(I^A_2 (a_1 + C)+ p^A_2))) + p_2^A \\
&= [I^A_1 + I_2^A - I^A_2 S_2 (S_2 I^A_2 S_2^T)^{-1} S^T_2 I^A_2]a_1 + \\
&~~~~~ \{p^A_1 + p^A_2 + I_2^A C + I^A_2 S_2 (S_2 I^A_2 S_2^T)^{-1}[\tau_2 - S^T_2 (I^A_2C + p^A_2)]\}
\end{array}
$$

把上市中的与构件$1$无关的变量整合一下得到：
$$
\begin{array}{rl}
I_2^a &= I_2^A - I^A_2 S_2 (S_2 I^A_2 S_2^T)^{-1} S^T_2 I^A_2 \\
p_2^a &= p^A_2 + I_2^A C + I^A_2 S_2 (S_2 I^A_2 S_2^T)^{-1}[\tau_2 - S^T_2 (I^A_2C + p^A_2)]
\end{array}
$$
通过上式可知，$I_2^a$和$p^a_2$分别是构件$2$对构件$1$的等效惯量和等效偏置作用力的投影。假如已知每个构件的等效惯量$I_i^A$和等效偏置作用力$p^A_i$，则可以递推得到子构件对父构件的影响。

补充一个小知识（虽然没什么用）：
$$
\begin{array}{rl}
f_i &= I^A_i a_i + p^A_i \\
&= I^a_i a_{\lambda (i)} + p^a_i
\end{array}
$$
上式的证明，只需要将$a_{\lambda(i)} = a_i - C - S_i \ddot q_i$代入到第一行即可证明。

## 铰接体算法

上述已经证明了，子构件对父构件的影响，包括等效惯量和等效偏置力。

对于末端构件，显然其没有子构件，因此其等效惯量$I^A_{end}$就是它本身。同理，其上的等效偏置作用，也仅有科氏力（包含了离心力）和外力。所以，推导过程如下：

第一步：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\算法流程\铰接体算法步骤一.png)

上式中，$c_i$是科氏加速度（包括离心加速度），$v_i\times ^* I_i v_i$是科氏力和向心力。最后一项是外力，之所以取负号，是因为外力+关节作用力，才共同产生了加速度和偏置作用力。因此是负号。

第二步：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\算法流程\铰接体算法步骤二.png)

当构件$i$不止一个子构件的时候，多个子构件对其的作用是线性叠加的（显然成立）。而$3,4$行代表$i$构件对其父构件的投影惯性矩阵和投影偏置加速度。

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\算法流程\铰接体算法步骤三.png)

最后可以先求出关节角加速度，再求解对应构件的加速度。上述过程在**铰接体正动力学推导**有详细的说明。

## 铰接体算法的简化

在**铰接体算法**中，有大量的变量是重复出现的，因此可以将这些变量进行整理，得到更加简化的算法。

定义变量：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\算法流程\铰接体算法简化步骤一.png)

从而**铰接体算法**步骤$2，3$可以简化为：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\算法流程\铰接体算法简化步骤二.png)

## 浮动基模型的铰接体算法

不同于根节点锁死的铰接体算法，对于浮动基模型而言，根节点构件具备完整的6个自由度。当等效惯量和等效偏置作用力完成迭代，即完成**铰接体算法**步骤$1,2$之后，我们已知，根节点的等效惯量$I^A_b$和偏置作用力$p^A_b$（忽略重力加速度），则此时：
$$
f_b = I^A_b a_b + p^A_b
$$
而根节点已经没有父节点了，$f_b = 0$，可知：
$$
a_b = -\frac{p^A_b}{I^A_b}
$$
除根节点以外，其余构件的计算方法同**铰接体算法**。因此浮动基模型的铰接体算法如下：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人正动力学\图片\算法流程\浮动基铰接体算法.png)

上图中，右侧最后根节点的加速度还加上了重力加速度。实际环境中，重力加速度必然存在。但是在整个迭代过程中，并不需要考虑重力加速度，是因为可以把整个铰接体模型均处在相同的重力加速度下，则可以认为是环境在做相对于模型的$-a_g$的加速运动，而模型本身不发生运动。最后计算完毕再加入重力加速度。上式中实际上每一个$a_i$都需要加上重力加速度。只是通常我们只关心根节点的空间加速度，和其他构件之间的关节角加速度。因此上图中省略了$a_i = a_i + a_g$这个步骤。

## 动力学正解的应用

动力学正解在一般控制中并不使用，通常是作为仿真环境的运动解算器。比如设计了某种控制算法，想知道这个算法在仿真环境中的实际效果，则需要知道，在给定调价下，模型真实的运动情况是，就需要通过动力学正解，计算各个构件的加速度，从而对时间积分，更新位置和速度。

在《四足机器人接触模型》中介绍了两种模型，MIT采用的默认模型是冲量接触模型，同时也具备弹簧阻尼模型。

**弹簧阻尼模型仿真**

首先将参数$use\_spring\_damper = 1$，这时会使用弹簧阻尼模型。其他参数均为默认，开启原地踏步。0.3倍速度。

<video id="video" controls="" preload="none"> <source id="mp4" src="视频\弹簧阻尼接触模型原地踏步.mp4" type="video/mp4"> </video>

可见，机器狗运动时有明显的颠簸感。同时足端作用力方向快速变化，同时伴随足端的滑移。这是由于采用的弹簧阻尼模型，在接触初期，接触面正压力较小，摩擦力无法阻止足端运动，因此表现出滑移，从而足端所受合理的方向也不断发生变化。

对比$use\_spring\_damper =0 $，采用冲量接触模型，其他参数均为默认，开启原地踏步。0.3倍速度。

<video id="video" controls="" preload="none"> <source id="mp4" src="视频\冲量接触模型原地踏步.mp4" type="video/mp4" width="500"> </video>

机器狗运动时平稳性大大提高。足端不再发生滑移，同时足端作用力稳定。

**弹簧阻尼模型的动力学正解**

由于弹簧阻尼模型计算足端作用力时，与地面的渗透深度、足端垂直于地面的速度呈现正相关性。因此可以将足端作用力看成外力。

则可以使用**铰接体算法**，计算系统的加速度。后续将**铰接体算法**称为$ABA$算法。

所以整个仿真过程如下：

![](D:\运动控制组相关文件\文件\Markdown\四足机器人\四足机器人接触模型\图片\弹簧阻尼模型\图片\弹簧阻尼模型下的系统仿真.png)

其中接触判定流程如下：
$$
\begin{array}{rl}
&for ~ i =1:n\_contact \\
&~~~~~~~ 
for~j~=~1:n\_collision\\
&~~~~~~~ ~~~~~~ penetration[i]~= distance(contact[i],collision[j],collision\_z[j])\\
&~~~~~~~ ~~~~~~ fz[i] = penetration[i]~<~0?(-k_S\cdot penetration[i] + k_D \cdot v[i]):0\\
&~~~~~~~ ~~~~~~ ft[i] = fz[i] * \mu\\
&~~~~~~~ ~~~~~~ f[i] = fz[i] + ft[i]\\
&~~~~~~~ ~~~~~~ runABA(f,dstate[i]) \\
&~~~~~~~ ~~~~~~ state(i+1) = state(i) + dstate[i] \cdot \Delta t \\
&~~~~~~~ end\\
&end

\end{array}
$$
上述流程中，$n\_contact$是接触判定点的数量。机器人一共设定了16个接触判定点，分别为本体的8个顶点，四条腿的膝关节4个点和足端4个点。$distance()$计算的是每个接触判定点和碰撞体表面的距离，也就是渗透深度。$fz[i]$是弹簧阻尼模型下的足端正压力，$ft[i]$是切向作用力。

实际代码使用的方法比上述流程复杂一点，但是原理是相通的。如下：
$$
\begin{array}{rl}
&for ~ i =1:n\_contact \\
&~~~~~~~ 
for~j~=~1:n\_collision\\
&~~~~~~~ ~~~~~~ deflectionRate[i] = (-K_S / K_D) * tangentialDeflections[i];\\
&~~~~~~~ ~~~~~~ penetration[i]~= distance(contact[i],collision[j],collision\_z[j])\\
&~~~~~~~ ~~~~~~ fz[i] = penetration[i]~<~0?(\sqrt{penetration[i]} \cdot (-K_S\cdot penetration[i] - K_D \cdot v[i])):0\\
&~~~~~~~ ~~~~~~ ft[i] = \sqrt{penetration[i]}(-K_S \cdot tangentialDeflections[i] -K_D \cdot deflectionRate[i])\\
&~~~~~~~ ~~~~~~ ft[i] = min(ft[i], fz[i]\cdot \mu)\\
&~~~~~~~ ~~~~~~ f[i] = fz[i] + ft[i]\\
&~~~~~~~ ~~~~~~ tangentialDeflections[i+1] = tangentialDeflections[i] + deflectionRate[i] \cdot \Delta t 
&~~~~~~~ ~~~~~~ runABA(f,dstate[i]) \\
&~~~~~~~ ~~~~~~ state(i+1) = state(i) + dstate[i] \cdot \Delta t \\
&~~~~~~~ end\\
&end

\end{array}
$$
上式中，对切向也采用了弹簧阻尼模型，而且计算方法也变为:
$$
f = \sqrt{x}(K_Sx + K_D \dot x)
$$
需要说明的是，算法实际中，足端速度和地面形变速度是相同的（认为接触点不发生形变）

**冲量接触模型的动力学正解**

冲量接触模型认为，地面是不会发生形变的，并且在接触瞬间速度反向，即：
$$
\dot x_{i+1} = -K_R \dot x_{i} + K_S x_i
$$
同理，切向作用力也不能大于摩擦力的上限。

因此计算流程为：
$$
\begin{array}{rl}
&for ~ i =1:n\_contact \\
&~~~~~~
for~j~=~1:n\_collision\\
&~~~~~~ ~~~~~~ penetration[i]~= distance(contact[i],collision[j],collision\_z[j])\\
&~~~~~~ ~~~~~~ runABA(0,dstate[i]) \\
&~~~~~~ ~~~~~~ state[i+1] +  = state[i] + dstate[i] \cdot \Delta t \\
&~~~~~~ ~~~~~~ for~k=1:10\\
&~~~~~~ ~~~~~~ ~~~~~~ runABA(f,dstate'[k+1]) \\
&~~~~~~ ~~~~~~ ~~~~~~ new\_state[i+1] = state[i+1] + dstate'[k+1]\\
&~~~~~~ ~~~~~~ ~~~~~~ v^{des}_{gc} = -K_R v[i] + K_S penetration[i]\\
&~~~~~~ ~~~~~~ ~~~~~~ v_{gc} = velocity(new\_state[i+1])\\
&~~~~~~ ~~~~~~ endif(for ~ (m=1:n\_gc) |v^{des}_{gc} - v_{gc}]| < Error)\\
&~~~~~~ end\\
&end

\end{array}
$$
上式中的流程与弹簧阻尼模型不同的是，由于足端作用力是需要求解的。因此上式第$4$行，首先假设没有足端作用力，其他状态不变的情况下，计算系统的状态变化速率$dstate$，从而更新了速度。但实际上由于碰撞点的存在，实际模型不可能按照第$5$行的状态运行。因此这个状态只是一个临时变量。第六行的再此循环，是为了通过迭代找出合适的碰撞作用力。因此，在第$7$行的时候再次使用了$ABA$模型。不同的是，由于第四行已经使用了除接触力以外的所有作用力，在第$7$行计算的时候，$v,f_i,a_g$均为零。基于这个方法计算得到接触力产生的加速度。积分后得到速度。第$8$行加速度在碰撞点处的速度，由于接触面的约束作用，在垂直接触面的方向上速度为零。

**优化方法——计算单向等效惯量**

如果使用上述方法的，则需要不断寻找合适的作用力。由于最终判定的依据是足端速度，而输入是作用力，二者没有直接的关系，因此这个过程并不会快速迭代收敛。MIT对上述方法进行了优化。
$$
\Delta v = v_{gc}^{des} - v_{gc}
$$
假设在单次仿真时间里作用力不发生改变（合理的假设，任何算法都无法描述高于仿真频率），则该周期内的冲量：
$$
E = \Lambda \Delta v = F \Delta t
$$
上式中，$\Lambda$描述的是，接触点的沿着$\Delta v$方向的惯量，即假设存在作用力$F$作用在模型上，作用点会产生加速度$a$，而该加速度在$F$上的投影$a'$满足：
$$
F = \Lambda a'
$$
由于迭代过程是关于$v$，且增量为$\Delta v$，意味着可以基于$v$进行迭代了（将原本对于足端接触力$F$的计算，转换为速度的计算，每一次如果存在偏差$\Delta v_i$，则直接将冲量偏差$\Delta v_i \cdot \Lambda$进行累加，直至$\Delta v_i \cdot \Lambda < Error $。

因此，首先需要计算出一个接触点$j$对应的与正压力方向的$\Lambda_j$。

由于此时计算$ABA$模型不再需要考虑$v,\tau,a_g$（**冲量接触模型的动力学正解**中已经说明了），因此浮动基模型的加速度计算公式可以简化。由于此时只有碰撞点$j$上有外力（每一个接触点单独计算这个过程），则其仅对父构件产生等效偏置作用。
$$
\begin{array}{rl}
p^i_{\lambda(i)} &= p^i_{\lambda(i)} + {}^{\lambda(i)}X^{*}_{i}p^a_I\\
p^i_{\lambda(i)} &= p^i_{\lambda(i)} + {}^{i}X^{T}_{\lambda(i)}p^a_I \\
p^i_{\lambda(i)} &= p^i_{\lambda(i)} + {}^{i}X^{T}_{\lambda(i)}(p^A_i + I^A_i S_i(S_i^T I^A_i S_i)^{-1}(-S_i^T p_i^A))\\
p^i_{\lambda(i)} &= p^i_{\lambda(i)} + ({}^{i}X^{T}_{\lambda(i)} - {}^{i}X^{T}_{\lambda(i)} I^A_i S_i(S_i^T I^A_i S_i)^{-1}S_i^T)p^A_i\\
p^i_{\lambda(i)} &= p^i_{\lambda(i)} + ({}^{i}X_{\lambda(i)} - S_i(S_i^T I^A_i S_i)^{-1}S_i^TI^A_i {}^{i}X_{\lambda(i)})^Tp^A_i\\
\end{array}
$$
如果将${}^{i}X_{\lambda(i)} - S_i(S_i^T I^A_i S_i)^{-1}S_i^TI^A_i {}^{i}X_{\lambda(i)}$提前求解，并且当做已知变量${}^{i}\chi_{\lambda(i)}$。同时$p^i_{\lambda(i)}$的初值为0，因此对$j$构件至根节点的构件，只需要不断左乘${}^{i}\chi_{\lambda(i)}$即可。

显然此时：
$$
a_b = -\frac{P_b^A}{I^A_b} = \frac{\chi^{b*}_kf^e_k}{I^A_b}
$$
而加速度的递推公式：
$$
\begin{array}{rl}
a_i &= a' + S_i \ddot q_i\\
&= {}^iX_{\lambda(i)}a_{\lambda(i)} + S_i (S_i^T I^A_i S_i)^{-1}(-S^T_ip^A_i - S_i^TI_i^A {}^iX_{\lambda(i)}a_{\lambda(i)})) \\
&= ({}^iX_{\lambda(i)} - S_i (S_i^T I^A_i S_i)^{-1}S_i^TI_i^A {}^iX_{\lambda(i)})a_{\lambda(i)} - S_i (S_i^T I^A_i S_i)^{-1}S_i^T p^A_i \\
&= {}^{i}\chi_{\lambda(i)} a_{\lambda(i)} - S_i D^{-1}S_i^T p^A_i
\end{array}
$$
利用上式逐渐递推至根节点，有：
$$
\begin{array}{rl}
a_i &= {}^{i}\chi_{i-1} {}^{i-1}\chi_{i-2} \cdots {}^{1}\chi_{b}a_{b} - S_i D_i^{-1}S_i^T p^A_i - 
{}^{i}\chi_{i-1} S_{i-1} D_{i-1}^{-1}S_{i-1}^T p^A_{i-1} - {}^{i}\chi_{i-1} {}^{i-1}\chi_{i-2} S_i D_{i-2}^{-1}S_{i-2}^T p^A_{i-2} - \\

&\cdots -  {}^{i}\chi_{i-1} {}^{i-1}\chi_{i-2} \cdots {}^{2}\chi_{1} S_1 D_1^{-1}S_1^T p^A_1 \\
&={}^{i}\chi_{b}a_{b} - \sum^{i}_{1} {}^{i}\chi_{j} S_j D_{j}^{-1}S_{j}^T p^A_{j}
\end{array} \label{加速度递推关系式}
$$
至此，求出了加速度递推关系式。假设此时单位接触作用力为$f_c = [0,0 ,0,0,0,1]^T$（定义c为以接触点为原点，作用力方向为$Z$轴，$X$轴任意的坐标系），则可以定义坐标系$C$，满足$f^i_c = X_c^if_c$。其在根节点的加速度已知为
$$
a_{b} = \frac{\chi^{b*}_kf^e_k}{I^A_b} = \chi^{b*}_i \cdot X_c^if_c
$$

进而根节点的加速度不断传递至$C$系，即${}^{i}\chi_{b}a_{b} = X_i^c {}^{i}\chi_{b} \chi^{b*}_i \cdot X_c^{i*}f_c$。这个就是接触点加速度中包含的本体加速度的分量，也就是公式$\ref{加速度递推关系式}$的最后一行的等式右边第一项。而这个加速在力方向上的投影，需要再左乘$f^T_c$，从而$\Lambda^{-1}_b = \frac{\chi^{b*}_i \cdot X_c^if_c}{I^A_v}$

多么惊人的一个结果。

公式$\ref{加速度递推关系式}$的其余项，同理有，
$$
\begin{array}{rl}
\Lambda^{-1}_i &= f_c^T X_i^c {}^{i}\chi_{j} S_j D_{j}^{-1}S_{j}^T p^A_{j} \\
&= \frac{ (S_{j}^T p^A_{j})^2}{D_j} \\
\end{array}
$$
从而$\Lambda^{-1} = \sum^{i}_{b} \Lambda^{-1}_i$

**优化方法——计算单位作用力下的铰接体加速度**

当采用弹簧阻尼接触模型时，足端作用力是确定的，因此可以直接计算$ABA$模型。而冲量接触模型需要迭代。若单位作用力$f_c = [0,0 ,0,0,0,1]^T$对系统产生的加速度为$a$，则有：
$$
\Delta state = a \cdot |f| \cdot \Delta t = a\cdot E = \Lambda \Delta v
$$
上式意味着，铰接体的运动速度，可以转化为接触点上的某一个方向的速度变化量。**优化方法——计算单向等效惯量**已经讨论了这种转化可以开展迭代。

$f_c$产生的加速度$a_b$在已经讨论过了。代入到浮动基的$ABA$模型：
$$
\begin{array}{rl}
\ddot q_1 &= D^{-1}_i(u_i - U^T_i a') \\
\ddot q_1 &= (S_1^T I^A_1 S_1)^{-1} (-S^T_1 p^A_1 -S^T_1I^A_1 X^1_b a_b)\\
\ddot q_i &= (S_i^T I^A_i S_i)^{-1} (-S^T_i p^A_i -S^T_iI^A_i X^i_{\lambda i} a_i)\\
&= -(S_i^T I^A_i S_i)^{-1} S^T_i p^A_i - (S_i^T I^A_i S_i)^{-1} S^T_iI^A_i X^i_{\lambda i} a_i \\
&= -D^{-1}_iS^T_ip^A_i - D^{-1}_iS^T_i I^A_i X^i_{\lambda i} a_i \\
\end{array}
$$
代入公式$\ref{加速度递推关系式}$：
$$
\begin{array}{rl}
\ddot q_i &= -D^{-1}_iS^T_ip^A_i - D^{-1}_iS^T_i I^A_i X^i_{\lambda(i)}({}^{i}\chi_{b}a_{b} - \sum^{i}_{1} {}^{i}\chi_{j} S_j D_{j}^{-1}S_{j}^T p^A_{j}) \\
&= -D^{-1}_iS^T_i I^A_i X^i_{\lambda(i)} {}^{i}\chi_{b}a_{b} -D^{-1}_iS^T_ip^A_i + D_iS^T_i I^A_i X^i_{\lambda(i)}
\sum^{i}_{1} {}^{i}\chi_{j} S_j D_{j}^{-1}S_{j}^T p^A_{j} \\
\end{array} \label{关节角加速度递推公式}
$$
观察上式，$(-D^{-1}_iS^T_i I^A_i X^i_{\lambda(i)})^T = (\chi^i_{\lambda(i)} - X^i_{\lambda(i)})^T\cdot S_i$。因此上式可以直接计算，也可以按照代码中的方法：

令$m = (\chi^i_{\lambda(i)} - X^i_{\lambda(i)})^T S_i$，构造矩阵$Q$满足：
$$
\begin{array}{rl}
q_{ii} &= 1 \\
q_{ij} &= (\chi^{j}_{i}m)^T S_j  \\
\end{array}
$$
其中$j$代指$i$的父构件序列。

再将单位向量$f_c$代入，有：
$$
\sum^{i}_{1} q_{ij} \frac{1}{D^{-1}_j}S^T_j p^A_j = D_iS^T_i I^A_i X^i_{\lambda(i)}
\sum^{i}_{1} {}^{i}\chi_{j} S_j D_{j}^{-1}S_{j}^T p^A_{j}
$$
而公式$\ref{关节角加速度递推公式}$的第一项$a_0$的系数就是$(\chi^{b}_{i}m)^T$。因此迭代过程也可以进一步简化计算量。过程如下：

1. 构造$Q$阵，计算$m$的时候，可以去中间变量，$n_i = m_i  =  (\chi^i_{\lambda(i)} - X^i_{\lambda(i)})^T S_i$，而$n_{\lambda(i)} = (\chi ^i_{\lambda(i)})^T n_i$;
2. 构造$W$阵，每一行为$n_b^T$;
3. 初始化变量$f_c$，迭代求解$p^A_j$，$\ddot q_i$

上述的方法大大的减少了计算量，但同时提高了理解的难度。如果对性能有要求可以这么做，否则理解到公式$\ref{加速度递推关系式},\ref{关节角加速度递推公式}$即可。

